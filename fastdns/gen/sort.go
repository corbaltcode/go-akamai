package main

// Generates sort methods for *RecordList types

import (
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"os"
	"strings"
	"text/template"
)

var code *template.Template = template.Must(template.New("code").Parse(`
func (rl {{.}}) Len() int      { return len(rl) }
func (rl {{.}}) Swap(i, j int) { rl[i], rl[j] = rl[j], rl[i] }
func (rl {{.}}) Less(i, j int) bool {
	if rl[i].Name != rl[j].Name {
		return rl[i].Name < rl[j].Name
	}
	// Backup method: use JSON encoding
	mi, err := json.Marshal(rl[i])
	if err != nil {
		panic(err)
	}
	mj, err := json.Marshal(rl[j])
	if err != nil {
		panic(err)
	}
	return bytes.Compare(mi, mj) <= 0
}
`))

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	dir := os.Args[1]
	if !strings.HasSuffix(dir, "/") {
		dir += "/"
	}
	destName := dir + "sort.go"
	p, err := build.Default.ImportDir(dir, 0)
	check(err)
	config := types.Config{
		IgnoreFuncBodies: true,
		Importer:         importer.For("source", nil),
	}
	typeInfo := &types.Info{
		Defs: make(map[*ast.Ident]types.Object),
	}
	astFiles := make([]*ast.File, 0)
	fset := token.NewFileSet()
	for _, name := range p.GoFiles {
		astf, err := parser.ParseFile(fset, dir+name, nil, 0)
		check(err)
		astFiles = append(astFiles, astf)
	}
	_, err = config.Check(dir, fset, astFiles, typeInfo)
	check(err)
	dest, err := os.Create(destName)
	check(err)
	fmt.Fprintf(dest, `// Code generated by gen.go. DO NOT EDIT
package %s

import (
	"bytes"
	"encoding/json"
)
`, p.Name)
	for _, astf := range astFiles {
		for _, node := range astf.Decls {
			decl, ok := node.(*ast.GenDecl)
			if !ok {
				continue
			}
			for _, spec := range decl.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				typeDef := typeInfo.Defs[ts.Name]
				_, ok = typeDef.Type().(*types.Named).Underlying().(*types.Slice)
				if !ok {
					// Non-struct type
					continue
				}
				if strings.HasSuffix(typeDef.Name(), "RecordList") {
					// Found a slice type named "*RecordList". Make sort methods for it.
					code.Execute(dest, ts.Name)
				}
			}
		}
	}
}
